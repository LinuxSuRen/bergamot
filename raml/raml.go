package raml

import (
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"

	"github.com/alauda/bergamot/contexts"
	"github.com/alauda/bergamot/log"
	"github.com/alauda/loggo"
	raml "github.com/tsaikd/go-raml-parser/parser"
)

// Methods client methods
type Methods map[string]Method

// Method represents an API function for a specific service
type Method func(context.Context) (int, interface{}, error)

// Config setup client
type Config struct {
	// Name gives a name to the client
	Name string
	// Endpoint is a fully qualified HTTP endpoint e.g. http://alauda.cn
	Endpoint string
	// Version specifies at the end of the endpoint. If not given will
	// use just as given in the API documentation
	Version string
	// Timeout will setup standard timeouts for all requests
	// unless the request give a specific timeout
	Timeout time.Duration
}

// Client http client generated by a raml document
type Client struct {
	Config  Config
	Methods Methods

	client *http.Client
	log    log.Logger
}

// NewClient constructor
func NewClient(config Config, logger log.Logger) *Client {
	return &Client{
		Config: config,
		client: http.DefaultClient,
		log:    log.GetSafe(logger),
	}
}

// Setup setup all methods based on the raml documentation
func (c *Client) Setup(doc raml.RootDocument) *Client {
	c.client.Timeout = c.Config.Timeout
	//
	for r, res := range doc.Resources {
		fmt.Println(res, r)
	}
	return c
}

func (c *Client) describe(parent string, res raml.Resources) {
}

func (c *Client) genURL(url string) string {
	fmtString := urlVersionFmt
	if c.Config.Version == "" {
		fmtString = urlFmt
	}
	return fmt.Sprintf(fmtString, c.Config.Endpoint, url)
	// Example:
	// "http://final.org/v1/status/{uuid}"
}

const (
	nameFmt       = "%s/%s"
	urlVersionFmt = "%s/%s/%s"
	urlFmt        = "%s/%s"
	argFmt        = "{%s}"
)

func (c *Client) genMethod(url, method string, desc raml.Method) Method {
	if desc.DisplayName == "" {
		desc.DisplayName = fmt.Sprintf(nameFmt, url, method)
	}
	// generates url
	finalURL := c.genURL(url)
	// ss
	//
	f := func(ctx context.Context) (status int, data interface{}, err error) {
		var (
			body   interface{}
			url    string
			req    *http.Request
			resp   *http.Response
			reader io.Reader
		)
		body = contexts.GetBody(ctx)
		url = c.processArgs(finalURL, contexts.GetArgs(ctx))
		if req, err = http.NewRequest(method, url, body); err != nil {
			c.log.StError("http.client", loggo.Fields{
				"method": method,
				"url":    url,
				"err":    err,
				"body":   body,
			})
			return
		}
		c.addQueryParams(req, contexts.GetParams(ctx))
		if resp, err = c.client.Do(req); err != nil {
			c.log.StError("http.client", loggo.Fields{
				"method":  method,
				"url":     url,
				"err":     err,
				"body":    body,
				"request": req,
			})
			return
		}
		stats = resp.StatusCode
		resp.Body.Read
		return
	}
	return f
	// return method
}

func (c *Client) processArgs(url string, args map[string]string) string {
	if len(args) > 0 {
		for k, v := range args {
			placeholder := fmt.Sprintf(argFmt, k)
			if strings.Contains(url, placeholder) {
				url = strings.Replace(url, placeholder, v, -1)
			}
		}
	}
	return url
}

func (c *Client) addQueryParams(req *http.Request, params map[string]string) {
	if len(params) == 0 {
		// nothing to do
		return
	}
	// adding parameters and encoding
	query := req.URL.Query()
	for k, v := range params {
		query.Add(k, v)
	}
	req.URL.RawQuery = query.Encode()
}

// Method returns the appropriate method for calling
func (c *Client) Method(method string) Method {
	if met, ok := c.Methods[method]; ok {
		return met
	}
	// not implemented
	return c.notImplemented
}

var (
	// ErrNotImplemented common error for not implemented methods
	ErrNotImplemented = errors.New("method not implemented")
)

// Request sends a request by the name of the api
func (c *Client) notImplemented(data context.Context) (status int, body interface{}, err error) {
	return http.StatusNotImplemented, nil, ErrNotImplemented
}
